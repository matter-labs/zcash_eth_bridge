use std::time::Duration;

use tracing::level_filters::LevelFilter;
use tracing_subscriber::EnvFilter;
use zcash_eth_bridge::eth::sender::EthSender;
use zcash_eth_bridge::types::StateUpdate;

use zcash_eth_bridge::eth::watcher::EthWatcher;
use zcash_eth_bridge::zcash::sender::TzeSender;
use zcash_eth_bridge::zcash::watcher::ZcashWatcher;

#[derive(Debug)]
struct Config {
    zcash_rpc: String,
    eth_rpc: String,
    eth_bridge_address: String,
    wzec_token_address: String,
    eth_operator_pk: String,
}

impl Config {
    pub fn hardcoded() -> Self {
        Self {
            zcash_rpc: "127.0.0.1:18232".to_string(),
            eth_rpc: "http://127.0.0.1:8545".to_string(),
            // This value is obtained by running `deploy_anvil.sh` on a fresh anvil instance.
            eth_bridge_address: "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512".to_string(),
            // This value is obtained by running `deploy_anvil.sh` on a fresh anvil instance.
            wzec_token_address: "0x5FbDB2315678afecb367f032d93F642f64180aa3".to_string(),

            // This private key corresponds to the first account generated by anvil.
            eth_operator_pk: "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80"
                .to_string(),
        }
    }
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(
            EnvFilter::builder()
                .with_default_directive(LevelFilter::INFO.into())
                .from_env_lossy(),
        )
        .init();

    let config = Config::hardcoded();
    let zcash_watcher = ZcashWatcher::new(&config.zcash_rpc);
    let eth_watcher = EthWatcher::new(
        &config.eth_rpc,
        &config.eth_bridge_address,
        &config.wzec_token_address,
    );

    let eth_sender = EthSender::new(
        &config.eth_rpc,
        &config.eth_operator_pk,
        &config.eth_bridge_address,
        &config.wzec_token_address,
    );

    let mut zcash_sender = TzeSender::new(&config.zcash_rpc).await?;
    let (mut stf_tze_outpoint, mut stf_tze_output) = zcash_sender.deploy().await?; // TODO: should take txid/n as input I guess?

    let mut start_block_zcash = zcash_watcher.get_block_count().await?;
    let mut start_block_eth = eth_watcher.get_block_number().await?;

    let mut prev_block_hash_zcash = zcash_watcher.get_block(start_block_zcash - 1).await?.hash();
    let mut prev_block_hash_eth = eth_watcher.get_block(start_block_eth - 1).await?.hash();

    loop {
        tokio::time::sleep(Duration::from_secs(5)).await;
        let current_block_zcash = zcash_watcher.get_block_count().await?;
        let current_block_eth = eth_watcher.get_block_number().await?;

        if current_block_eth < start_block_eth || current_block_zcash < start_block_zcash {
            // TODO: should we send an op in this scenario? I guess realistically not.
            continue;
        }

        tracing::warn!(
            "Processing blocks ZEC {}-{}, ETH {}-{}",
            start_block_zcash,
            current_block_zcash,
            start_block_eth,
            current_block_eth
        );

        let mut zcash_blocks = Vec::new();
        for height in start_block_zcash..=current_block_zcash {
            let block = zcash_watcher.get_block(height).await?;
            zcash_blocks.push(block);
        }

        let mut eth_blocks = Vec::new();
        for number in start_block_eth..=current_block_eth {
            let block = eth_watcher.get_block(number).await?;
            eth_blocks.push(block);
        }

        let eth_to_zec_transfers = eth_watcher
            .extract_eth_to_zec_transfers(&eth_blocks)
            .await?;
        let (zec_to_eth_transfers, zcash_deposit_outpoints) = zcash_watcher
            .extract_zec_to_eth_transfers(&zcash_blocks)
            .await?;

        let state_update = StateUpdate {
            old_eth_block: start_block_eth - 1,
            new_eth_block: current_block_eth,
            old_eth_hash: prev_block_hash_eth.0,
            new_eth_hash: eth_blocks.last().unwrap().hash().0,
            old_zcash_block: (start_block_zcash - 1) as u64,
            new_zcash_block: current_block_zcash as u64,
            old_zcash_hash: prev_block_hash_zcash.0,
            new_zcash_hash: zcash_blocks.last().unwrap().hash().0,
            eth_to_zec_transfers: eth_to_zec_transfers.clone(),
            zec_to_eth_transfers: zec_to_eth_transfers.clone(),
        };

        if !state_update.eth_to_zec_transfers.is_empty() {
            tracing::warn!(
                "Processing {} ETH -> ZEC transfers in blocks {}-{}",
                state_update.eth_to_zec_transfers.len(),
                start_block_eth,
                current_block_eth
            );
            for t in &state_update.eth_to_zec_transfers {
                tracing::warn!("  {:?}", t);
            }
        }

        if !state_update.zec_to_eth_transfers.is_empty() {
            tracing::warn!(
                "Processing {} ZEC -> ETH transfers in blocks {}-{}",
                state_update.zec_to_eth_transfers.len(),
                start_block_zcash,
                current_block_zcash
            );
            for t in &state_update.zec_to_eth_transfers {
                tracing::warn!("  {:?}", t);
            }
        }

        (stf_tze_outpoint, stf_tze_output) = zcash_sender
            .update_zcash(
                (stf_tze_outpoint, stf_tze_output),
                zcash_deposit_outpoints,
                state_update.clone(),
            )
            .await?;
        eth_sender.update_bridge(state_update).await?;
        zcash_sender.wait_for_tx(stf_tze_outpoint.txid()).await?;

        start_block_eth = current_block_eth + 1;
        prev_block_hash_eth = eth_blocks.last().unwrap().hash();
        start_block_zcash = current_block_zcash + 1;
        prev_block_hash_zcash = zcash_blocks.last().unwrap().hash();
    }
}
